#include <metal_stdlib>
using namespace metal;
struct SceneVertex { float3 position [[attribute(0)]]; float3 normal [[attribute(1)]]; float2 texCoord [[attribute(2)]]; };
struct SceneUniforms { float4x4 modelMatrix; float4x4 viewMatrix; float4x4 projectionMatrix; float3x3 normalMatrix; float3 cameraPosition_worldSpace; };
struct MaterialUniforms { float4 color; float indexOfRefraction; float specularIntensity; float shininess; float ambientLight; };
struct VertexOut { float4 position [[position]]; float3 normal_worldSpace; float3 world_position; float3 viewDirection_worldSpace; };
vertex VertexOut vertexMain(SceneVertex v [[stage_in]], constant SceneUniforms &u [[buffer(1)]]) { VertexOut o; float4 pos_world_h = u.modelMatrix * float4(v.position, 1.0); o.world_position = pos_world_h.xyz; o.position = u.projectionMatrix * u.viewMatrix * pos_world_h; o.normal_worldSpace = normalize(u.normalMatrix * v.normal); o.viewDirection_worldSpace = normalize(u.cameraPosition_worldSpace - o.world_position); return o; }
fragment float4 fragmentSkybox(VertexOut f [[stage_in]], texture2d<float> envTex [[texture(0)]]) { constexpr sampler s(coord::normalized, address::repeat, filter::linear); float3 dir = normalize(f.normal_worldSpace); float2 uv = float2(atan2(dir.z, dir.x) / (2.0 * M_PI_F) + 0.5, acos(dir.y) / M_PI_F); return envTex.sample(s, uv); }
fragment float4 fragmentGlass(VertexOut f [[stage_in]], constant MaterialUniforms &material [[buffer(1)]], texture2d<float> envTex [[texture(0)]]) { constexpr sampler s(coord::normalized, address::repeat, filter::linear); float3 N = normalize(f.normal_worldSpace); float3 V = normalize(f.viewDirection_worldSpace); float R0 = pow((1.0 - material.indexOfRefraction) / (1.0 + material.indexOfRefraction), 2.0); float fresnel = R0 + (1.0 - R0) * pow(1.0 - saturate(dot(V, N)), 5.0); float3 reflectionDir = reflect(-V, N); float2 reflectionUV = float2(atan2(reflectionDir.z, reflectionDir.x) / (2.0 * M_PI_F) + 0.5, acos(reflectionDir.y) / M_PI_F); float4 reflectionColor = envTex.sample(s, reflectionUV); float IOR_R = material.indexOfRefraction; float IOR_G = material.indexOfRefraction + 0.005; float IOR_B = material.indexOfRefraction + 0.01; float3 refractionDir_R = refract(-V, N, 1.0 / IOR_R); float3 refractionDir_G = refract(-V, N, 1.0 / IOR_G); float3 refractionDir_B = refract(-V, N, 1.0 / IOR_B); float2 refractionUV_R = float2(atan2(refractionDir_R.z, refractionDir_R.x)/(2.0*M_PI_F)+0.5, acos(refractionDir_R.y)/M_PI_F); float2 refractionUV_G = float2(atan2(refractionDir_G.z, refractionDir_G.x)/(2.0*M_PI_F)+0.5, acos(refractionDir_G.y)/M_PI_F); float2 refractionUV_B = float2(atan2(refractionDir_B.z, refractionDir_B.x)/(2.0*M_PI_F)+0.5, acos(refractionDir_B.y)/M_PI_F); float4 refractionColor; refractionColor.r = envTex.sample(s, refractionUV_R).r; refractionColor.g = envTex.sample(s, refractionUV_G).g; refractionColor.b = envTex.sample(s, refractionUV_B).b; refractionColor.a = 1.0; float3 L = normalize(float3(0.8, 1.0, -0.5)); float3 H = normalize(L + V); float specFactor = pow(saturate(dot(N, H)), material.shininess); float3 specularComponent = float3(1.0, 1.0, 1.0) * specFactor * material.specularIntensity; float4 baseColor = mix(refractionColor, reflectionColor, fresnel); float3 finalColor = baseColor.rgb * material.color.rgb + specularComponent + (baseColor.rgb * material.ambientLight); float alpha = material.color.a * (1.0 - fresnel * 0.5); return float4(finalColor, alpha); }
